//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace SharpArch.Specifications.SharpArch.Core.NHibernateValidator
{
    using System;
    using System.Collections.Generic;

    using Castle.Windsor;

    using CommonServiceLocator.WindsorAdapter;

    using global::SharpArch.Core;
    using global::SharpArch.Core.CommonValidator;
    using global::SharpArch.Core.DomainModel;
    using global::SharpArch.Core.NHibernateValidator;
    using global::SharpArch.Core.NHibernateValidator.CommonValidatorAdapter;
    using global::SharpArch.Core.PersistenceSupport;

    using Machine.Specifications;

    using Microsoft.Practices.ServiceLocation;

    using System.Linq;

    public abstract class specification_for_has_unique_domain_signature_validator
    {
        protected static IValidator validator;

        protected static string entityName;

        protected static string entitySSN;

        Establish context_for_each = () =>
            {
                entitySSN = "111-22-3333";
                entityName = "codai";

                

                InitServiceLocatorInitializer();
            };

        protected static void InitServiceLocatorInitializer()
        {
            IWindsorContainer container = new WindsorContainer();

            container.AddComponent("duplicateChecker", typeof(IEntityDuplicateChecker), typeof(DuplicateCheckerStub));
            container.AddComponent("validator", typeof(IValidator), typeof(Validator));

            ServiceLocator.SetLocatorProvider(() => new WindsorServiceLocator(container));
        }

        #region Private Methods

        [HasUniqueDomainSignature]
        public class Contractor : Entity
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignatureWithGuidId]
        public class ObjectWithGuidId : EntityWithTypedId<Guid>
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignature]
        public class ObjectWithStringIdAndValidatorForIntId : EntityWithTypedId<string>
        {
            #region Properties

            [DomainSignature]
            public string Name { get; set; }

            #endregion
        }

        [HasUniqueDomainSignatureWithStringId]
        public class User : EntityWithTypedId<string>
        {
            #region Properties

            [DomainSignature]
            public string SSN { get; set; }

            #endregion
        }

        public class DuplicateCheckerStub : IEntityDuplicateChecker
        {
            public bool DoesDuplicateExistWithTypedIdOf<TId>(IEntityWithTypedId<TId> entity)
            {
                Check.Require(entity != null);

                if (entity as Contractor != null)
                {
                    var contractor = entity as Contractor;
                    return !string.IsNullOrEmpty(contractor.Name) && contractor.Name.ToLower() == "codai";
                }
                else if (entity as User != null)
                {
                    var user = entity as User;
                    return !string.IsNullOrEmpty(user.SSN) && user.SSN.ToLower() == "111-22-3333";
                }
                else if (entity as ObjectWithGuidId != null)
                {
                    var objectWithGuidId = entity as ObjectWithGuidId;
                    return !string.IsNullOrEmpty(objectWithGuidId.Name) && objectWithGuidId.Name.ToLower() == "codai";
                }

                // By default, simply return false for no duplicates found
                return false;
            }
        }

        #endregion
    }

    [Subject(typeof(HasUniqueDomainSignatureValidator))]
    public class when_a_duplicate_entity_exists_during_validation_process : specification_for_has_unique_domain_signature_validator
    {
        static Contractor contractor;

        static IEnumerable<IValidationResult> invalidValues;

        Establish context = () =>
            {
                Check.UseAssertions = false;
                contractor = new Contractor();
                contractor.Name = entityName;

                invalidValues = contractor.ValidationResults();
            };

        It should_set_is_valid_to_false = () => contractor.IsValid().ShouldBeFalse();

        It should_have_at_least_one_invalid_value = () => invalidValues.Count().ShouldBeGreaterThan(0);
    }

    [Subject(typeof(HasUniqueDomainSignatureValidator))]
    public class when_a_duplicate_entity_with_a_guid_id_exists_during_validation_process : specification_for_has_unique_domain_signature_validator
    {
        static ObjectWithGuidId objectWithGuidId1;

        static ObjectWithGuidId objectWithGuidId2;

        static IEnumerable<IValidationResult> invalidValues;

        Establish context = () =>
        {
            Check.UseAssertions = false;
            objectWithGuidId1 = new ObjectWithGuidId();
            objectWithGuidId1.Name = entityName;

            objectWithGuidId2 = new ObjectWithGuidId();
            objectWithGuidId2.Name = "Whatever";

            invalidValues = objectWithGuidId1.ValidationResults();
        };

        It should_set_is_valid_to_false_for_duplicate = () => objectWithGuidId1.IsValid().ShouldBeFalse();

        It should_have_at_least_one_invalid_value = () => invalidValues.Count().ShouldBeGreaterThan(0);

        It should_set_is_valid_to_true_for_not_duplicate = () => objectWithGuidId2.IsValid().ShouldBeTrue();
    }

    [Subject(typeof(HasUniqueDomainSignatureValidator))]
    public class when_a_duplicate_entity_with_a_string_id_exists_during_validation_process : specification_for_has_unique_domain_signature_validator
    {
        static User user;

        static IEnumerable<IValidationResult> invalidValues;

        Establish context = () =>
        {
            Check.UseAssertions = false;
            user = new User();
            user.SSN = entitySSN;

            invalidValues = user.ValidationResults();
        };

        It should_set_is_valid_to_false = () => user.IsValid().ShouldBeFalse();

        It should_have_at_least_one_invalid_value = () => invalidValues.Count().ShouldBeGreaterThan(0);
    }

    [Subject(typeof(HasUniqueDomainSignatureValidator))]
    public class when_no_duplicate_entity_exists_during_validation_process : specification_for_has_unique_domain_signature_validator
    {
        static Contractor contractor;

        static IEnumerable<IValidationResult> invalidValues;

        Establish context = () =>
        {
            Check.UseAssertions = false;
            contractor = new Contractor();
            contractor.Name = "Whatever";

            invalidValues = contractor.ValidationResults();
        };

        It should_set_is_valid_to_true = () => contractor.IsValid().ShouldBeTrue();

        It should_have_no_invalid_value = () => invalidValues.Count().ShouldBeLessThan(1);
    }

    [Subject(typeof(HasUniqueDomainSignatureValidator))]
    public class when_the_the_wrong_validator_type_is_used : specification_for_has_unique_domain_signature_validator
    {
        static ObjectWithStringIdAndValidatorForIntId invalidObject;

        static Exception result;

        Establish context = () =>
        {
            Check.UseAssertions = false;
            invalidObject = new ObjectWithStringIdAndValidatorForIntId();
            invalidObject.Name = "Whatever 234";
        };

        Because of = () => result = Catch.Exception(() => invalidObject.ValidationResults());

        It should_throw_a_precondition_exception = () => result.ShouldBeOfType<PreconditionException>();
    }
}